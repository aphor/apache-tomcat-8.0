<?xml version="1.0"?>
<!DOCTYPE document [
  <!ENTITY project SYSTEM "project.xml">
]>
<document url="aio.html">

    &project;

  <properties>
    <title>Advanced IO and Tomcat</title>
    <author>Remy Maucherat</author>
    <author>Filip Hanik</author>
  </properties>

<body>

  <section name="Introduction">

  <p>
    With usage of APR or NIO APIs as the basis of its connectors, Tomcat is 
    able to provide a number of extensions over the regular blocking IO 
    as provided with support for the Servlet API.
  </p>

  <p>
    <b>IMPORTANT NOTE: Usage of these features requires using the APR or NIO
    HTTP connectors. The classic java.io HTTP connector and the AJP connectors
    do not support them.</b>
  </p>

  </section>

  <section name="Comet support">

  <p>
    Comet support allows a servlet to process IO aynchronously, recieving
    events when data is available for reading on the connection (rather than
    always using a blocking read), and writing data back on connections
    asychnonously (most likely responding to some event raised from some
    other source).
  </p>

  <subsection name="Comet Terms"> 
  <p>
    Comet Connection - For the readability of this document we will be referring an open ended HTTP request and an open
    ended HTTP response that are mapped to a Cometprocessor as a &quot;Comet Connection&quot;.
  </p>
  <p>
    Comet Processor - a servlet that implements the <code>org.apache.catalina.CometProcessor</code> interface.
    Used to process comet connections and the events on the connection
  </p>
  <p>
    Comet Event - an event triggered by the container related to a Comet Connection
  </p>
  <p>
    Open Ended Request - a HTTP request that is either chunked or has a very large content length, allowing 
    data to be sent at different times. This is how Tomcat gets around the request/response methodology of 
    the HTTP protocol allowing Comet Processors to send and receive data on the socket synchronously and asynchronously.
  </p>
  <p>
    Open Ended Response - see Open Ended Request
  </p>
  <p>
    Active Comet Connection, a comet connection that currently is associated with a TCP connection and an open ended request/response.
  </p>
  <p>
    Blocking Comet Connection, an invocation of the read/write methods will block until data was received/sent.
  </p>
  <p>
    Non blocking Comet Connection, an invocation of the read/write methods will not block.
  </p>
  <p>
    Comet operation - comet connections can register themselves for a set of events to be 
    notified of. The different operations are:<br/>
    OP_READ - results in a READ event when data has been received<br/>
    OP_WRITE - results in a WRITE event when the socket is ready to receive data<br/>
    OP_CALLBACK - results in a CALLBACK event on a Tomcat thread. 
  </p>
  <p>
    Connection Centric - Comet connections are based on actual IO events on a TCP connection from the TCP layer. 
    This is different from servlets that are based on HTTP requests and responses, by the HTTP protocol above the TCP layer.
  </p>
  <p>
    Closing a comet connection - may not actually mean that the underlying TCP connection is closed. Tomcat still
    respects the <code>maxKeepAliveRequests</code> attribute of the connector, and may decide to keep the connection
    open. This is the case in the event of a connection timeout, the event ERROR/TIMEOUT is signaled and the 
    TCP connection is reused for the next HTTP request.
  </p>
  </subsection>
  
  <subsection name="Comet Lifecycle"> 
  <p>
    The lifecycle and event cycle of a Comet Connection is slightly different than a regular servlet.
    Instead the life/event cycle is very &quot;connection centric&quot; and based on IO events, rater then 
    a request/response cycle like a normal HTTP request. This is the most common mistake developers make when they 
    start writing comet servlets, is that they don't realize that it is all based around these different events, and 
    that the events are some what connection centric.
  </p>
  <p>
    A comet interaction is started by the container invoking the event method on the Comet Processor 
    and the event will have a BEGIN type. For a deeper explanation of types, keep reading.
    Once a BEGIN event has been invoked, the Comet Connection is active. At this type, the Comet Event object
    reference can be used to reference the HttpServletRequest/HttpServletResponse objects for asynchronous actions
    such as reading or writing from the streams or readers/writers. At this point the comet connection is considered active
    or initiated.
  </p>
  <p>
    Once the Comet connection is active, the comet processor will receive events from the container.
    These events are defined in the section <a href="#CometEvent">below</a>.<br/>
    A comet processor may register itself for events, and receive the events when they happen.
    In a similar fashion, a comet processor may unregister itself from comet events and
    use the <code>isReadable/isWriteable</code> methods on the comet event to detect the state 
    of the comet connection. The registered events will be in effect until they are unregistered,
    the comet connection is closed or terminated.
    By default a comet connection gets registered for READ events upon initiation.
    <br/>
    The event registration can be compared to poll or select structures of different operating systems,
    and also bear some resemblances with the <code>java.nio</code> API.
  </p>
  <p>
    Since Comet Connections deal directly with the IO layer of the container/connection and read and writes can be done 
    asynchronously, caution and care should be excersized when programming this. the comet connection itself is not thread safe
    as such an implementation would suffer performance issues, instead it is up to the comet processor developer to ensure that
    thread safety is reached and properly handled. 
    As an example, registering the comet connection for READ events and at the same time performing asynchronous reads
    on the input stream or the reader, can cause data corruption and dead locks.
    Same way, using multiple threads to do writes to the output stream or writer can have the same effect.
    <br/>To be thread safe, one can synchronize on the event object, but you will also need to coordinate it with 
    events that are registered.
  </p>
  <p>
    There is an event that is not IO based, that is the <code>CometEvent.EventType.CALLBACK</code> event.
    This is an event that is forced by Tomcat when the <code>OP_CALLBACK</code> operation is registered.
    Using the OP_CALLBACK operation, Tomcat will spawn a Tomcat worker thread that you can use to piggy back
    on for reading/writing data or performing other operations, and not having to have spawn and synchronize 
    your own background threads.<br/>
    An example scenarion would be where you have one thread pulling content for different comet clients.
    When the background thread has content for a client, it can store it in the request object as an attribute,
    then register for the OP_CALLBACK event. Once the CALLBACK event, then the application can use Tomcat's worker
    thread to write the data to the client.<br/>
    Tomcat guarantees that only one thread will be invoking the CometProcessor event for a particular client,
    so by using the Tomcat worker threads to perform your actions, you are thread safe without the expense of 
    locks or synchronized methods.<br/>
    Another usage scenario for the CALLBACK event, is when you close the comet connection asynchronously and you want 
    it processed by tomcat without depending on a timeout or another IO event. This would look like
    <source>
      ...
      event.close();
      event.register(CometEvent.CometOperation.OP_CALLBACK);
      ...
    </source>
  </p>
  </subsection>

  <subsection name="CometEvent">
  
  <p>
    Servlets which implement the <code>org.apache.catalina.CometProcessor</code>
    interface will have their event method invoked rather than the usual service
    method, according to the event which occurred. The event object gives
    access to the usual request and response objects, which may be used in the
    usual way. The main difference is that those objects remain valid and fully
    functional at any time between processing of the BEGIN event until processing
    an END or ERROR event.
    The following event types exist:
  </p>
  
  <ul>
  <li>EventType.BEGIN: will be called at the beginning 
     of the processing of the connection. It can be used to initialize any relevant 
     fields using the request and response objects. During the BEGIN event you may also configure 
     your comet connection for blocking or non blocking mode. using the <code>configure</code>
     method on the comet event object. Between the end of the processing  
     of this event, and the beginning of the processing of the end or error events,
     it is possible to use the response object to write data on the open connection.
     Note that the response object and depedent OutputStream and Writer are still 
     not synchronized, so when they are accessed by multiple threads, 
     synchronization is mandatory. After processing the initial event, the request 
     is considered to be committed.<br/><br/></li>
  <li>EventType.READ: This indicates that input data is available, and that one read can be made
     without blocking. The <code>available()</code> and <code>ready()</code> methods of the InputStream or
     Reader may be used to determine if there is a risk of blocking: the servlet
     should read while data is reported available, and can make one additional read
     should read while data is reported available. Not reading all the data, is not recommended,
     as it may lead to unexpected behavior depending on the connector implementation.<br/>
     When encountering a read error, the servlet should report it by propagating the exception properly. 
     Throwing an exception will cause the error event to be invoked, and the connection 
     will be closed. <br/>
     Alternately, it is also possible to catch any exception, perform clean up
     on any data structure the servlet may be using, and using the <code>close()</code> method
     of the event object. It is not recommended to attempt reading data from the request 
     object outside of the execution of this method/event if the comet connection is registered for 
     the READ event. Instead unregister the read event to perform asynchronous reads.<br/>
     On some platforms, like Windows, a client disconnect is indicated by a READ event.
     Reading from the stream may result in -1, an IOException or an EOFException.
     Make sure you properly handle all these three cases.
     If you don't catch the IOException, Tomcat will instantly invoke your event chain with an ERROR as 
     it catches the error for you, and you will be notified of the error at that time.<br/><br/>
  </li>
  <li>EventType.WRITE: If you wish to be notified whether you can write data to the underlying TCP socket,
      register your comet connection for this event. Tomcat will invoke this event, and you can write to the response 
      object. This event is not needed nor should be used unless you are running the comet connection in non blocking mode.<br/><br/>
  </li>
 <li>EventType.CALLBACK: When a comet connection is registered using the OP_CALLBACK operation,
     Tomcat will generate the CALLBACK event periodically. The CALLBACK will always 
     be invoked using a Tomcat worker thread, just like the other event types.<br/><br/>
  </li>
  <li>EventType.END: End may be called to end the processing of the request. Fields that have
     been initialized in the begin method should be reset. After this event has
     been processed, the request and response objects, as well as all their dependent
     objects will be recycled and used to process other requests. End will also be 
     called when data is available and the end of file is reached on the request input
     (this usually indicates the client has pipelined a request).<br/><br/></li>
  <li>EventType.ERROR: Error will be called by the container in the case where an IO exception
     or a similar unrecoverable error occurs on the connection. Fields that have
     been initialized in the begin method should be reset. After this event has
     been processed, the request and response objects, as well as all their dependent
     objects will be recycled and used to process other requests.<br/><br/></li>
  </ul>

  <p>
    There are some event subtypes which allow finer processing of events (note: some of these
    events require usage of the org.apache.catalina.valves.CometConnectionManagerValve valve):
  </p>

  <ul>
  <li>EventSubType.TIMEOUT: The connection timed out (sub type of ERROR); note that this ERROR 
    type is not fatal, and the connection will not be closed unless the servlet uses the close 
    method of the event.
  </li>
  <li>EventSubType.CLIENT_DISCONNECT: The client connection was closed (sub type of ERROR).
    method of the event.
  </li>
  <li>EventSubType.IOEXCEPTION: An IO exception occurred, such as invalid content, for example, 
    an invalid chunk block (sub type of ERROR).
  </li>
  <li>EventSubType.WEBAPP_RELOAD: The web application is being reloaded (sub type of END).
  </li>
  <li>EventSubType.SESSION_END: The servlet ended the session (sub type of END).
  </li>
  </ul>

  <p>
    As described above, the typical lifecycle of a Comet request will consist in a series of
    events such as: BEGIN -> READ -> READ -> READ -> ERROR/TIMEOUT. At any time, the servlet 
    may end processing of the request by using the close method of the event object.
  </p>
  
  </subsection>

  <subsection name="CometFilter">
  
  <p>
    Similar to regular filters, a filter chain is invoked when comet events are processed.
    These filters should implement the CometFilter interface (which works in the same way as 
    the regular Filter interface), and should be declared and mapped in the deployment
    descriptor in the same way as a regular filter. The filter chain when processing an event
    will only include filters which match all the usual mapping rules, and also implement
    the CometFiler interface.
  </p>
  
  </subsection>

  <subsection name="Example code">
  
  <p>
    The following pseudo code servlet implments asynchronous chat functionality using the API
    described above:
  </p>
  
  <source>
public class ChatServlet
    extends HttpServlet implements CometProcessor {

    protected ArrayList&lt;HttpServletResponse> connections = 
        new ArrayList&lt;HttpServletResponse>();
    protected MessageSender messageSender = null;
    
    public void init() throws ServletException {
        messageSender = new MessageSender();
        Thread messageSenderThread = 
            new Thread(messageSender, "MessageSender[" + getServletContext().getContextPath() + "]");
        messageSenderThread.setDaemon(true);
        messageSenderThread.start();
    }

    public void destroy() {
        connections.clear();
        messageSender.stop();
        messageSender = null;
    }

    /**
     * Process the given Comet event.
     * 
     * @param event The Comet event that will be processed
     * @throws IOException
     * @throws ServletException
     */
    public void event(CometEvent event)
        throws IOException, ServletException {
        HttpServletRequest request = event.getHttpServletRequest();
        HttpServletResponse response = event.getHttpServletResponse();
        if (event.getEventType() == CometEvent.EventType.BEGIN) {
            log("Begin for session: " + request.getSession(true).getId());
            PrintWriter writer = response.getWriter();
            writer.println("&lt;!doctype html public \"-//w3c//dtd html 4.0 transitional//en\">");
            writer.println("&lt;head>&lt;title>JSP Chat&lt;/title>&lt;/head>&lt;body bgcolor=\"#FFFFFF\">");
            writer.flush();
            synchronized(connections) {
                connections.add(response);
            }
        } else if (event.getEventType() == CometEvent.EventType.ERROR) {
            log("Error for session: " + request.getSession(true).getId());
            synchronized(connections) {
                connections.remove(response);
            }
            event.close();
        } else if (event.getEventType() == CometEvent.EventType.END) {
            log("End for session: " + request.getSession(true).getId());
            synchronized(connections) {
                connections.remove(response);
            }
            PrintWriter writer = response.getWriter();
            writer.println("&lt;/body>&lt;/html>");
            event.close();
        } else if (event.getEventType() == CometEvent.EventType.READ) {
            InputStream is = request.getInputStream();
            byte[] buf = new byte[512];
            do {
                int n = is.read(buf); //can throw an IOException
                if (n &gt; 0) {
                    log("Read " + n + " bytes: " + new String(buf, 0, n) 
                            + " for session: " + request.getSession(true).getId());
                } else if (n &lt; 0) {
                    error(event, request, response);
                    return;
                }
            } while (is.available() > 0);
        }
    }

    public class MessageSender implements Runnable {

        protected boolean running = true;
        protected ArrayList&lt;String> messages = new ArrayList&lt;String>();
        
        public MessageSender() {
        }
        
        public void stop() {
            running = false;
        }

        /**
         * Add message for sending.
         */
        public void send(String user, String message) {
            synchronized (messages) {
                messages.add("[" + user + "]: " + message);
                messages.notify();
            }
        }

        public void run() {

            while (running) {

                if (messages.size() == 0) {
                    try {
                        synchronized (messages) {
                            messages.wait();
                        }
                    } catch (InterruptedException e) {
                        // Ignore
                    }
                }

                synchronized (connections) {
                    String[] pendingMessages = null;
                    synchronized (messages) {
                        pendingMessages = messages.toArray(new String[0]);
                        messages.clear();
                    }
                    // Send any pending message on all the open connections
                    for (int i = 0; i &lt; connections.size(); i++) {
                        try {
                            PrintWriter writer = connections.get(i).getWriter();
                            for (int j = 0; j &lt; pendingMessages.length; j++) {
                                writer.println(pendingMessages[j] + "&lt;br>");
                            }
                            writer.flush();
                        } catch (IOException e) {
                            log("IOExeption sending message", e);
                        }
                    }
                }

            }

        }

    }

}
  </source>
  
  </subsection>
  <subsection name="Comet timeouts">
    <p>If you are using the NIO connector, you can set individual timeouts for your different comet connections.
       To set a timeout, simple set a request attribute like the following code shows:
       <source>CometEvent event.... event.setTimeout(30*1000);</source> 
       <br/>You can set the timeout on the comet connection at any point in time, even asynchronously.
       Setting a timeout to 1 (one milliseconds) doesn't guarantee that it will timeout at that time.
       Setting the timeout gurantees that Tomcat wont timeout the connection before the connection has been idle
       for the configured time. The time it actually times out depends on many factors, such as how busy the server is,
       when the last timeout scan was run, etc., but generally a timeout will occur fairly close to its configured value.
    </p>
    <p>If you are using the APR connector, all Comet connections will have the same timeout value. It is <code>soTimeout*50</code>
    </p>
  </subsection>

  </section>

  <section name="Asynchronous writes">

  <p>
    When APR or NIO is enabled, Tomcat supports using sendfile to send large static files.
    These writes, as soon as the system load increases, will be performed 
    asynchronously in the most efficient way. Instead of sending a large response using
    blocking writes, it is possible to write content to a static file, and write it
    using a sendfile code. A caching valve could take advantage of this to cache the
    response data in a file rather than store it in memory. Sendfile support is
    available if the request attribute <code>org.apache.tomcat.sendfile.support</code>
    is set to <code>Boolean.TRUE</code>.
  </p>
  
  <p>
    Any servlet can instruct Tomcat to perform a sendfile call by setting the appropriate
    response attributes. When using sendfile, it is best to ensure that neither the
    request or response have been wrapped, since as the response body will be sent later
    by the connector itself, it cannot be filtered. Other than setting the 3 needed 
    response attributes, the servlet should not send any response data, but it may use
    any method which will result in modifying the response header (like setting cookies).
  </p>
  
  <ul>
  <li>org.apache.tomcat.sendfile.filename: Canonical filename of the file which will be sent as
      a String</li>
  <li>org.apache.tomcat.sendfile.start: Start offset as a Long</li>
  <li>org.apache.tomcat.sendfile.start: End offset as a Long</li>
  </ul>

  </section>

</body>
</document>
